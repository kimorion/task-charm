
- реализовать парсер по ключевым словам
- реализовать удаление через контекст
- прикрутить алису

ПАРСЕР:

1) Найдено ключевое слово команды? 
    (list, ls, l, список, сп, удали) - учитывать количество слов в сообщении
    
 
2) Найдено ключевое слово даты? 
    (сегодня завтра послезавтра (допустить ошибки)) (уточнение времени справа)
                            
3) Дата задана коротко в начале? (в 5, в 3)

4) Обычная задача без времени

- - - - - - - - - - - - - - -

[в 5] занятие английского 
    .Contains("в").WithNext(_ => shortTimeParser(_)).IsFirst().IsNotLast()
    
сегодня [в 5] [в 15:00] [вечером] 
    .ContainsAnyOut(["сегодня", "завтра", "послезавтра"], out DateTime)
    .WithNext("в").WithNextOut(_ => shortTimeParser<T, T?>(_), out TimeSpan)
    .WithNext("в").WithNextOut(_ => fullTimeParser<T, T?>(_), out TimeSpan)
    .WithNextOut(_ => speechTimeParser<T, T?>(_), out TimeSpan)
    
в понедельник [в 5] [в 15:00] [вечером] 
    .Contains("в").ContainsAnyOut(["понедельник", "вторник", "среда"], out DateTime)
    .WithNext("в").WithNextOut(_ => shortTimeParser<T, T?>(_), out TimeSpan)
    .WithNext("в").WithNextOut(_ => fullTimeParser<T, T?>(_), out TimeSpan)
    .WithNextOut(_ => speechTimeParser<T, T?>(_), out TimeSpan)
    
1) Билдер основан на отношении И
2) 



Version 2.0 "Вложенная опциональность"

сегодня [ [(в 5) (в 15:00)] [вечером] ] 
.Contains("сегодня")
    .BeginGuess()
        .BeginGuess()
            .BeginOption().WithNext("в").WithNextOut(timeParser)
            .BeginOption().WithNext("в").WithNextOut(fullTimeParser)
        .EndGuess()
        
        .BeginGuess()
            .WithAnyNextOut("вечером, утром, днем")
        .EndGuess()
    .EndGuess()
.Build()

Word.SearchPatternRight() => сегодня [ 
                                        [  в (5)>shortTimeParser часов || в (15:00)>fullTimeParser   ] 
                                        [ (вечером)>wordTimeParser ] 
                                     ] 

#Состояния интерпретатора
    read - читать следующий символ
    up   - увеличить уровень вложенности
    down - уменьшить уровень вложенности
    exit - искать ] или || или &&
    error - остановить работу, сообщить об ошибке           

#Синтаксис
    [] - новый уровень вложенности опциональности
    (*)>func - захватываемая группа, интерпретатор проверяет её наличие, в случае успеха передает функции func, 
              устанавливает текущему уровню результат успеха func
    || - логическое или. Устанавливает true, если текущий уровень false, иначе exit
    && - логическое и. Форсирует exit, если текущий уровень false
    

#Тезисы
1. Интерпретатор читает строку посимвольно
2. Неудача заставляет интерпретатор перейти на закрывающую ] или ||
3. Каждая опциональная группа [] создает логический уровень в стэке
4. Слова разделяются одним пробелом или группой пробелов
5. Между скобками пробелы необязательны
6. Интерпретатор является конечным автоматом (гениально!)
7. () - захватываемая группа, интерпретатор проверяет её наличие, в случае успеха передает функции
